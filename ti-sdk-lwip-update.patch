diff --git a/platforms/drivers/cc32xx-transceiver/wifi_if.c b/platforms/drivers/cc32xx-transceiver/wifi_if.c
index dc87582..9f3110a 100644
--- a/platforms/drivers/cc32xx-transceiver/wifi_if.c
+++ b/platforms/drivers/cc32xx-transceiver/wifi_if.c
@@ -84,6 +84,8 @@
 #include <ti/net/slnetconn.h>
 #include <ti/net/slnetif.h>
 
+#include "lwip/netif.h"
+
 #undef DEBUG_IF_NAME
 #undef DEBUG_IF_SEVERITY
 #define DEBUG_IF_NAME       "WIFI"
@@ -339,6 +341,7 @@ static int NetworkBypass(bool bEnableCmd)
     return rc;
 }
 
+#ifdef HANDLE_SIMPLELINK_EVENTS_IN_WIFI_IF
 /*********************** SimpleLink Event Handlers ***************************
  *****************************************************************************
           SimpleLink Callback Functions :WLAN, NETAPP and GENERAL EVENTS
@@ -605,7 +608,7 @@ void SimpleLinkFatalErrorEventHandler(SlDeviceFatal_t *slFatalErrorEvent)
         break;
     }
 }
-
+#endif //HANDLE_SIMPLELINK_EVENTS_IN_WIFI_IF
 
 __attribute__((weak)) void SimpleLinkSockEventHandler(SlSockEvent_t * pSock)
 {
@@ -752,16 +755,29 @@ static void SlWifiConnEventHandler(WifiConnEventId_e eventId , WifiConnEventData
  *****************************************************************************
           Network Ready (after MAC Connection), 
           IP Acquisition/Loss Inidcations,
-          TX/RX Handling   
+          TX/RX Handling
  *****************************************************************************
  */
-static void TcpipEventHandler(void *pNetif, TcpipStatue_e status, void * pParams)
+static void TcpipEventHandler(void *_pNetif, TcpipStatue_e status, void * pParams)
 {
     LOG_INFO("TcpipEventHandler(%d)\n\r", status);
     switch (status)
     {
     case E_TCPIP_STATUS_IP_ACQUIRED:
         Notify(WIFI_STATUS_CONNECTED_IP);
+
+        struct netif *pNetif = _pNetif;
+        if(!ip4_addr_isany_val(*netif_ip4_addr(pNetif))) {
+            SlNetAppEvent_t slNetAppEvent;
+            slNetAppEvent.Id = SL_NETAPP_EVENT_IPV4_ACQUIRED;
+            slNetAppEvent.Data.IpAcquiredV4.Ip = htonl(netif_ip4_addr(pNetif)->addr);
+            slNetAppEvent.Data.IpAcquiredV4.Gateway = htonl(netif_ip4_gw(pNetif)->addr);
+            slNetAppEvent.Data.IpAcquiredV4.Dns = htonl(netif_ip4_netmask(pNetif)->addr);
+
+            LOG_INFO("ipv4 = %x\n\r", slNetAppEvent.Data.IpAcquiredV4.Ip);
+            slcb_NetAppEvtHdlr(&slNetAppEvent);
+        }
+
         break;
     case E_TCPIP_STATUS_IP_LOST:
         Notify(WIFI_STATUS_CONNECTED);
diff --git a/platforms/ns/lwip/tcpip_if.c b/platforms/ns/lwip/tcpip_if.c
index f70a878..928d696 100644
--- a/platforms/ns/lwip/tcpip_if.c
+++ b/platforms/ns/lwip/tcpip_if.c
@@ -75,7 +75,7 @@
 #undef DEBUG_IF_NAME
 #undef DEBUG_IF_SEVERITY
 #define DEBUG_IF_NAME     "TCPIP_IF"
-#define DEBUG_IF_SEVERITY E_INFO
+#define DEBUG_IF_SEVERITY E_TRACE
 
 
 #define ETH_MAX_PAYLOAD 1514
@@ -302,12 +302,41 @@ static void LwipCB_linkDownDeferred(void *hNewif)
     m_bLinkUp = false;
 }
 
+uint8_t coalesceBuf[2048];
+
 static err_t LwipCB_wifiSend(struct netif *pNetif, struct pbuf * p)
 {
+///
+      struct pbuf * partialPkt;
+      int offset = 0;
+
+
+    //   if (p->len != p->tot_len) {
+    //        for(;;) {
+    //             LOG_ERROR("p->len != p->tot_len !!!, p->len=%d, p->tot_len=%d", p->len, p->tot_len);
+    //             sleep(1);
+    //         }
+    //   }
+
+      for (partialPkt = p; partialPkt != NULL; partialPkt = partialPkt->next)
+      {
+          if (offset + partialPkt->len > 1544)
+          {
+              for(;;) {
+                LOG_ERROR("offset + partialPkt->len > 1544 !!!");
+                sleep(1);
+              }
+          }
+          memcpy(coalesceBuf + offset, partialPkt->payload, partialPkt->len);
+          offset += partialPkt->len;
+      }
+
+
     if(netif_is_up(pNetif))
     {
         assert(m_fSendCallback); 
-        m_fSendCallback(pNetif, p->payload, p->len, 0);
+//      m_fSendCallback(pNetif, p->payload, p->len, 0);
+        m_fSendCallback(pNetif, coalesceBuf, p->tot_len, 0);
     }
     return (err_t) ERR_OK;
 }
@@ -381,11 +410,13 @@ int TCPIP_IF_setInterfaceState(void *hNetIf, TcpipInterfaceState_e state)
 {
     if (state == E_TCPIP_IF_UP)
     {
+        //LED_setOn(gLedBlueHandle, LED_BRIGHTNESS_MAX);
         LOG_DEBUG("[TCPIP_IF_setInterfaceState] I/F - UP!");
         tcpip_callback(LwipCB_interfaceUpDeferred, hNetIf);
     }
     else
     {
+        //LED_setOff(gLedBlueHandle);
         LOG_DEBUG("[TCPIP_IF_setInterfaceState] I/F - DOWN!");
         tcpip_callback(LwipCB_interfaceDownDeferred, hNetIf);
     }
@@ -401,6 +432,7 @@ int TCPIP_IF_notifyLinkChange(void *hNetIf, TcpipLinkState_e state)
     }
     else
     {
+        //LED_setOff(gLedBlueHandle);
         LOG_DEBUG("[TCPIP_IF_notifyLinkChange] I/F - DISCONNECTED!");
         tcpip_callback(LwipCB_linkDownDeferred, hNetIf);
     }
@@ -431,15 +463,84 @@ int   TCPIP_IF_pktLength(void *hPkt)
 
 int   TCPIP_IF_receive(void *hPkt, int pktLen, void *hNetif)
 {
+    int ret = 0;
+
     struct netif *pNetif = (struct netif*)hNetif;
 #ifdef TCPIP_IF_ZERO_COPY
     struct pbuf *pPkt = (struct pbuf *)hPkt;
 #else
     struct pbuf *pPkt =  pbuf_alloc(PBUF_LINK, pktLen, PBUF_POOL);
+
+
+    if (pPkt == NULL) {
+        for(;;) {
+            LOG_ERROR("[TCPIP_IF_receive] out of Link BUFS !!!");
+            sleep(1);
+        }
+    }
+
+
+#if 0
+    // Don't support fragmented pbufs
+    // sanity check in-case we can fragmented PBUF
+    if (pPkt->tot_len != pPkt->len) {
+        for(;;) {
+            LOG_DEBUG("[TCPIP_IF_receive] pPkt->tot_len != pPkt->len !!!");
+            sleep(1);
+        }
+    }
+
     memcpy(pPkt->payload, hPkt ,pktLen);
-#endif
+
+    // Is this needed - shouldn't be??
     pPkt->len = pktLen;
     pPkt->tot_len = pktLen;
-    return pNetif->input(pPkt, hNetif);
+
+#else
+    // support fragmented pbufs
+
+    struct pbuf *tempPkt = pPkt;
+
+    // If this not fragmented, then just copy the whole packet.
+    if (tempPkt->len == pktLen) {
+        memcpy(tempPkt->payload, hPkt, pktLen);
+    }
+    else if (tempPkt->tot_len == pktLen) {
+        // Copy in chunks into the pbufs
+        unsigned char *src = hPkt;
+        unsigned int sizeCopied = 0;
+
+        while (tempPkt != 0) {
+            memcpy(tempPkt->payload, src, tempPkt->len);
+            sizeCopied += tempPkt->len; // better to use remaining len?
+            src += tempPkt->len;
+            tempPkt = tempPkt->next;
+        }
+
+        // check
+        if (sizeCopied != pktLen) {
+            for(;;) {
+                LOG_ERROR("[TCPIP_IF_receive] sizeCopied != pktLen !!!");
+                sleep(1);
+            }
+        }
+    }
+    // first ensure that pbuf is big enough
+    else { //(pPkt->tot_len != pktLen)
+        for(;;) {
+            LOG_ERROR("[TCPIP_IF_receive] pPkt->tot_len != pktLen !!!");
+            sleep(1);
+        }
+    }
+#endif
+
+#endif
+    ret = pNetif->input(pPkt, hNetif);
+
+    if (ret != 0) {
+        LOG_ERROR("[TCPIP_IF_receive] pNetif->input failed !!!");
+        pbuf_free(pPkt);
+    }
+    return (ret);
 }
 
diff --git a/source/third_party/mbedtls/ti/port/entropy_alt.c b/source/third_party/mbedtls/ti/port/entropy_alt.c
index 16fe0f1..ecf08c0 100644
--- a/source/third_party/mbedtls/ti/port/entropy_alt.c
+++ b/source/third_party/mbedtls/ti/port/entropy_alt.c
@@ -118,19 +118,19 @@ int entropy_poll(void *data, unsigned char *output, size_t len, size_t *olen)
 }
 
 
-psa_status_t mbedtls_psa_external_get_random( mbedtls_psa_external_random_context_t *context,
-                                                uint8_t *output,
-                                                size_t output_size, 
-                                                size_t *output_length)
-{
-    int status;
-    unsigned short length;
-    length = (unsigned short)output_size;
-    status = sl_NetUtilGet(SL_NETUTIL_TRUE_RANDOM,0,output,&(length));
-    if (status==0)
-    {
-        *output_length = output_size;
-    }
-    return status;
-}
+// psa_status_t mbedtls_psa_external_get_random( mbedtls_psa_external_random_context_t *context,
+//                                                 uint8_t *output,
+//                                                 size_t output_size, 
+//                                                 size_t *output_length)
+// {
+//     int status;
+//     unsigned short length;
+//     length = (unsigned short)output_size;
+//     status = sl_NetUtilGet(SL_NETUTIL_TRUE_RANDOM,0,output,&(length));
+//     if (status==0)
+//     {
+//         *output_length = output_size;
+//     }
+//     return status;
+// }
 //-------------------------------------------------------------------------
\ No newline at end of file
diff --git a/source/third_party/mbedtls/ti/port/entropy_alt.h b/source/third_party/mbedtls/ti/port/entropy_alt.h
index ef2cefc..500ad05 100644
--- a/source/third_party/mbedtls/ti/port/entropy_alt.h
+++ b/source/third_party/mbedtls/ti/port/entropy_alt.h
@@ -30,14 +30,14 @@ extern "C" {
  *  recommended that the application provide a strong implementation of this
  *  API.
  */
-#include "psa/crypto_se_driver.h"
-#include <psa/crypto_types.h>
+// #include "psa/crypto_se_driver.h"
+// #include <psa/crypto_types.h>
 int mbedtls_platform_entropy_poll(void *data, unsigned char *output, size_t len);
 int entropy_poll(void *data, unsigned char *output, size_t len, size_t *olen);
-psa_status_t mbedtls_psa_external_get_random( mbedtls_psa_external_random_context_t *context,
-                                                uint8_t *output,
-                                                size_t output_size, 
-                                                size_t *output_length);
+// psa_status_t mbedtls_psa_external_get_random( mbedtls_psa_external_random_context_t *context,
+//                                                 uint8_t *output,
+//                                                 size_t output_size, 
+//                                                 size_t *output_length);
 #ifdef __cplusplus
 }
 #endif
