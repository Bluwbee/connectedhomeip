diff --git a/platforms/drivers/cc32xx-transceiver/wifi_if.c b/platforms/drivers/cc32xx-transceiver/wifi_if.c
index dc87582..835bfad 100644
--- a/platforms/drivers/cc32xx-transceiver/wifi_if.c
+++ b/platforms/drivers/cc32xx-transceiver/wifi_if.c
@@ -84,10 +84,12 @@
 #include <ti/net/slnetconn.h>
 #include <ti/net/slnetif.h>
 
+#include "lwip/netif.h"
+
 #undef DEBUG_IF_NAME
 #undef DEBUG_IF_SEVERITY
 #define DEBUG_IF_NAME       "WIFI"
-#define DEBUG_IF_SEVERITY   WIFI_IF_DEBUG_LEVEL
+#define DEBUG_IF_SEVERITY   E_TRACE //WIFI_IF_DEBUG_LEVEL
 
 #define WIFI_BUFF_SIZE 1544
 
@@ -335,10 +337,15 @@ static int NetworkBypass(bool bEnableCmd)
        rc = sl_NetCfgSet(SL_NETCFG_IPV4_STA_ADDR_MODE,SL_NETCFG_ADDR_DHCP_LLA,0,0);
        bEnabled = false;
     }
+
+    LOG_INFO("Disable power management");
+    sl_WlanPolicySet(SL_WLAN_POLICY_PM , SL_WLAN_ALWAYS_ON_POLICY, NULL,0);
+
     LOG_INFO("Configure N/W Bypass mode (%d)", rc);
     return rc;
 }
 
+#ifdef HANDLE_SIMPLELINK_EVENTS_IN_WIFI_IF
 /*********************** SimpleLink Event Handlers ***************************
  *****************************************************************************
           SimpleLink Callback Functions :WLAN, NETAPP and GENERAL EVENTS
@@ -605,7 +612,7 @@ void SimpleLinkFatalErrorEventHandler(SlDeviceFatal_t *slFatalErrorEvent)
         break;
     }
 }
-
+#endif //HANDLE_SIMPLELINK_EVENTS_IN_WIFI_IF
 
 __attribute__((weak)) void SimpleLinkSockEventHandler(SlSockEvent_t * pSock)
 {
@@ -755,16 +762,37 @@ static void SlWifiConnEventHandler(WifiConnEventId_e eventId , WifiConnEventData
           TX/RX Handling   
  *****************************************************************************
  */
-static void TcpipEventHandler(void *pNetif, TcpipStatue_e status, void * pParams)
+static void TcpipEventHandler(void *_pNetif, TcpipStatue_e status, void * pParams)
 {
     LOG_INFO("TcpipEventHandler(%d)\n\r", status);
     switch (status)
     {
     case E_TCPIP_STATUS_IP_ACQUIRED:
         Notify(WIFI_STATUS_CONNECTED_IP);
+
+        struct netif *pNetif = _pNetif;
+        if(!ip4_addr_isany_val(*netif_ip4_addr(pNetif))) {
+            SlNetAppEvent_t slNetAppEvent;
+            slNetAppEvent.Id = SL_NETAPP_EVENT_IPV4_ACQUIRED;
+            slNetAppEvent.Data.IpAcquiredV4.Ip = htonl(netif_ip4_addr(pNetif)->addr);
+            slNetAppEvent.Data.IpAcquiredV4.Gateway = htonl(netif_ip4_gw(pNetif)->addr);
+            slNetAppEvent.Data.IpAcquiredV4.Dns = htonl(netif_ip4_netmask(pNetif)->addr);
+
+            LOG_INFO("ipv4 = %x\n\r", slNetAppEvent.Data.IpAcquiredV4.Ip);
+            slcb_NetAppEvtHdlr(&slNetAppEvent);
+        }
+
         break;
     case E_TCPIP_STATUS_IP_LOST:
         Notify(WIFI_STATUS_CONNECTED);
+
+        SlNetAppEvent_t slNetAppEvent;
+        slNetAppEvent.Id = SL_NETAPP_EVENT_IPV4_LOST;
+        slNetAppEvent.Data.IpV4Lost.Status = status;
+
+        LOG_INFO("ipv4 lost status=%x\n\r", slNetAppEvent.Data.IpV4Lost.Status);
+        slcb_NetAppEvtHdlr(&slNetAppEvent);
+        
         break;
     default:
         break;
diff --git a/platforms/ns/lwip/tcpip_if.c b/platforms/ns/lwip/tcpip_if.c
index f70a878..0578beb 100644
--- a/platforms/ns/lwip/tcpip_if.c
+++ b/platforms/ns/lwip/tcpip_if.c
@@ -75,7 +75,7 @@
 #undef DEBUG_IF_NAME
 #undef DEBUG_IF_SEVERITY
 #define DEBUG_IF_NAME     "TCPIP_IF"
-#define DEBUG_IF_SEVERITY E_INFO
+#define DEBUG_IF_SEVERITY E_TRACE
 
 
 #define ETH_MAX_PAYLOAD 1514
@@ -302,12 +302,41 @@ static void LwipCB_linkDownDeferred(void *hNewif)
     m_bLinkUp = false;
 }
 
+uint8_t coalesceBuf[2048];
+
 static err_t LwipCB_wifiSend(struct netif *pNetif, struct pbuf * p)
 {
+///
+      struct pbuf * partialPkt;
+      int offset = 0;
+
+
+    //   if (p->len != p->tot_len) {
+    //        for(;;) {
+    //             LOG_ERROR("p->len != p->tot_len !!!, p->len=%d, p->tot_len=%d", p->len, p->tot_len);
+    //             sleep(1);
+    //         }
+    //   }
+
+      for (partialPkt = p; partialPkt != NULL; partialPkt = partialPkt->next)
+      {
+          if (offset + partialPkt->len > 1544)
+          {
+              for(;;) {
+                LOG_ERROR("offset + partialPkt->len > 1544 !!!");
+                sleep(1);
+              }
+          }
+          memcpy(coalesceBuf + offset, partialPkt->payload, partialPkt->len);
+          offset += partialPkt->len;
+      }
+
+
     if(netif_is_up(pNetif))
     {
         assert(m_fSendCallback); 
-        m_fSendCallback(pNetif, p->payload, p->len, 0);
+//      m_fSendCallback(pNetif, p->payload, p->len, 0);
+        m_fSendCallback(pNetif, coalesceBuf, p->tot_len, 0);
     }
     return (err_t) ERR_OK;
 }
@@ -381,11 +410,13 @@ int TCPIP_IF_setInterfaceState(void *hNetIf, TcpipInterfaceState_e state)
 {
     if (state == E_TCPIP_IF_UP)
     {
+        //LED_setOn(gLedBlueHandle, LED_BRIGHTNESS_MAX);
         LOG_DEBUG("[TCPIP_IF_setInterfaceState] I/F - UP!");
         tcpip_callback(LwipCB_interfaceUpDeferred, hNetIf);
     }
     else
     {
+        //LED_setOff(gLedBlueHandle);
         LOG_DEBUG("[TCPIP_IF_setInterfaceState] I/F - DOWN!");
         tcpip_callback(LwipCB_interfaceDownDeferred, hNetIf);
     }
@@ -401,6 +432,7 @@ int TCPIP_IF_notifyLinkChange(void *hNetIf, TcpipLinkState_e state)
     }
     else
     {
+        //LED_setOff(gLedBlueHandle);
         LOG_DEBUG("[TCPIP_IF_notifyLinkChange] I/F - DISCONNECTED!");
         tcpip_callback(LwipCB_linkDownDeferred, hNetIf);
     }
@@ -431,15 +463,89 @@ int   TCPIP_IF_pktLength(void *hPkt)
 
 int   TCPIP_IF_receive(void *hPkt, int pktLen, void *hNetif)
 {
+    int ret = 0;
+
     struct netif *pNetif = (struct netif*)hNetif;
 #ifdef TCPIP_IF_ZERO_COPY
     struct pbuf *pPkt = (struct pbuf *)hPkt;
 #else
     struct pbuf *pPkt =  pbuf_alloc(PBUF_LINK, pktLen, PBUF_POOL);
+
+
+    if (pPkt == NULL) {
+        // for(;;) {
+            LOG_ERROR("[TCPIP_IF_receive] out of Link BUFS !!!");
+            return -1;
+        //     sleep(1);
+        // }
+    }
+
+
+#if 0
+    // Don't support fragmented pbufs
+    // sanity check in-case we can fragmented PBUF
+    if (pPkt->tot_len != pPkt->len) {
+        for(;;) {
+            LOG_DEBUG("[TCPIP_IF_receive] pPkt->tot_len != pPkt->len !!!");
+            sleep(1);
+        }
+    }
+
     memcpy(pPkt->payload, hPkt ,pktLen);
-#endif
+
+    // Is this needed - shouldn't be??
     pPkt->len = pktLen;
     pPkt->tot_len = pktLen;
-    return pNetif->input(pPkt, hNetif);
+
+#else
+    // support fragmented pbufs
+
+    struct pbuf *tempPkt = pPkt;
+
+    // If this not fragmented, then just copy the whole packet.
+    if (tempPkt->len == pktLen) {
+        memcpy(tempPkt->payload, hPkt, pktLen);
+    }
+    else if (tempPkt->tot_len == pktLen) {
+        // Copy in chunks into the pbufs
+        unsigned char *src = hPkt;
+        unsigned int sizeCopied = 0;
+
+        while (tempPkt != 0) {
+            memcpy(tempPkt->payload, src, tempPkt->len);
+            sizeCopied += tempPkt->len; // better to use remaining len?
+            src += tempPkt->len;
+            tempPkt = tempPkt->next;
+        }
+
+        // check
+        if (sizeCopied != pktLen) {
+            // for(;;) {
+                LOG_ERROR("[TCPIP_IF_receive] sizeCopied != pktLen !!!");
+                pbuf_free(pPkt);
+                return -1;
+            //     sleep(1);
+            // }
+        }
+    }
+    // first ensure that pbuf is big enough
+    else { //(pPkt->tot_len != pktLen)
+        // for(;;) {
+            LOG_ERROR("[TCPIP_IF_receive] pPkt->tot_len != pktLen !!!");
+            pbuf_free(pPkt);
+            return -1;
+            // sleep(1);
+        // }
+    }
+#endif
+
+#endif
+    ret = pNetif->input(pPkt, hNetif);
+
+    if (ret != 0) {
+        LOG_ERROR("[TCPIP_IF_receive] pNetif->input failed !!!");
+        pbuf_free(pPkt);
+    }
+    return (ret);
 }
 
diff --git a/platforms/ns/net_log.c b/platforms/ns/net_log.c
index f55512e..e42f845 100644
--- a/platforms/ns/net_log.c
+++ b/platforms/ns/net_log.c
@@ -54,6 +54,8 @@
 #include "net_log.h"
 #include "debug_if.h"
 
+#include "trace.h"
+
 #undef DEBUG_IF_NAME
 #define DEBUG_IF_NAME       "NET"
 #undef DEBUG_IF_SEVERITY
@@ -86,6 +88,31 @@ typedef enum { false, true } bool;
 #define ICMP6_LOG  (1)
 #define IGMP_LOG   (1)
 
+#include <lwip/stats.h>
+
+#if 0
+#include "trace.h"
+void ETHERNET_logFrame(logType_e type, char *pIfName, uint32_t nBytes, uint8_t * p)
+{
+    char typeChar = (type==LOG_RX)?'<':'>';
+    trace_put('\n');
+    trace_put(',');
+    trace_put(typeChar);
+    trace_put(',');
+    uint8_t avialPbufChar;
+    if(lwip_stats.memp[17]->used < 10)
+    {
+        avialPbufChar = '0' + lwip_stats.memp[17]->used;
+    }
+    else
+    {
+        avialPbufChar = 'a' + (lwip_stats.memp[17]->used - 10);
+    }
+    trace_put(avialPbufChar);
+    trace_put('\n');
+}
+
+#else
 static uint32_t IPv6_LOG(char *buff, uint32_t offset, uint8_t *iphdr, int ipOffset)
 {
     int i;
@@ -124,6 +151,7 @@ static uint32_t IPv6_LOG(char *buff, uint32_t offset, uint8_t *iphdr, int ipOffs
 */
 void ETHERNET_logFrame(logType_e type, char *pIfName, uint32_t nBytes, uint8_t * p)
 {
+  
     uint16_t prot;
     uint8_t *ethhdr = p;
     char *pTypeStr = (type==LOG_RX)?"RCVD":"SENT";
@@ -263,6 +291,8 @@ void ETHERNET_logFrame(logType_e type, char *pIfName, uint32_t nBytes, uint8_t *
     }
     }
     LOG_TRACE("%s", buff);
+    //LOG_INFO(", %d, %s", lwip_stats.memp[17]->used, buff);
 }
+#endif
 
 
diff --git a/source/third_party/mbedtls/ti/port/entropy_alt.c b/source/third_party/mbedtls/ti/port/entropy_alt.c
index 16fe0f1..ecf08c0 100644
--- a/source/third_party/mbedtls/ti/port/entropy_alt.c
+++ b/source/third_party/mbedtls/ti/port/entropy_alt.c
@@ -118,19 +118,19 @@ int entropy_poll(void *data, unsigned char *output, size_t len, size_t *olen)
 }
 
 
-psa_status_t mbedtls_psa_external_get_random( mbedtls_psa_external_random_context_t *context,
-                                                uint8_t *output,
-                                                size_t output_size, 
-                                                size_t *output_length)
-{
-    int status;
-    unsigned short length;
-    length = (unsigned short)output_size;
-    status = sl_NetUtilGet(SL_NETUTIL_TRUE_RANDOM,0,output,&(length));
-    if (status==0)
-    {
-        *output_length = output_size;
-    }
-    return status;
-}
+// psa_status_t mbedtls_psa_external_get_random( mbedtls_psa_external_random_context_t *context,
+//                                                 uint8_t *output,
+//                                                 size_t output_size, 
+//                                                 size_t *output_length)
+// {
+//     int status;
+//     unsigned short length;
+//     length = (unsigned short)output_size;
+//     status = sl_NetUtilGet(SL_NETUTIL_TRUE_RANDOM,0,output,&(length));
+//     if (status==0)
+//     {
+//         *output_length = output_size;
+//     }
+//     return status;
+// }
 //-------------------------------------------------------------------------
\ No newline at end of file
diff --git a/source/third_party/mbedtls/ti/port/entropy_alt.h b/source/third_party/mbedtls/ti/port/entropy_alt.h
index ef2cefc..500ad05 100644
--- a/source/third_party/mbedtls/ti/port/entropy_alt.h
+++ b/source/third_party/mbedtls/ti/port/entropy_alt.h
@@ -30,14 +30,14 @@ extern "C" {
  *  recommended that the application provide a strong implementation of this
  *  API.
  */
-#include "psa/crypto_se_driver.h"
-#include <psa/crypto_types.h>
+// #include "psa/crypto_se_driver.h"
+// #include <psa/crypto_types.h>
 int mbedtls_platform_entropy_poll(void *data, unsigned char *output, size_t len);
 int entropy_poll(void *data, unsigned char *output, size_t len, size_t *olen);
-psa_status_t mbedtls_psa_external_get_random( mbedtls_psa_external_random_context_t *context,
-                                                uint8_t *output,
-                                                size_t output_size, 
-                                                size_t *output_length);
+// psa_status_t mbedtls_psa_external_get_random( mbedtls_psa_external_random_context_t *context,
+//                                                 uint8_t *output,
+//                                                 size_t output_size, 
+//                                                 size_t *output_length);
 #ifdef __cplusplus
 }
 #endif
